@c ref.texh
@c Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008,
@c   2009, 2010, 2011 Thien-Thi Nguyen
@c
@c This file is provided under the same terms as guile-pg.texi.

@c ---------------------------------------------------------------------------
@node    Database Connections
@chapter Procedures for managing connections

All sessions with a PostgreSQL database require a connection to be opened with
@code{pg-connectdb}.  When the default values of the options are sufficient,
you don't need to specify them.  Default values are also useful in creating a
connection dialog (user-interface element).

Guile-PG displays connection objects in one of the following formats:

@example
#<PG-CONN:DB:HOST:PORT:OPTIONS>   ; open
#<PG-CONN:->                      ; closed
@end example

@noindent
@var{db} is the database name, or @code{?}; @var{host} is the host
name, or socket directory name in the case of Unix-domain connections;
@var{port} is the TCP port
where the server is listening, empty in the case of Unix-domain connections;
and @var{options} is the same as would be returned by @code{pg-get-options}.
Everything else appears literally as shown here.  It is very strange to have
@var{db} be @code{?}; usually that indicates a bug either in Guile-PG or in
PostgreSQL.

@tsin i pg-connection?
@erindex due to bad connection
@tsin i pg-connectdb
@tsin i pg-conndefaults

@heading Example
@lisp
(define (user-count host tcp-port)
  (let* ((conn (pg-connectdb
                (format #f "host=~A port=~A dbname=template1"
                        host tcp-port)))
         (result (pg-exec conn "SELECT COUNT(*) FROM pg_user")))
    (and result
         (eq? 'PGRES_TUPLES_OK (pg-result-status result))
         (string->number (pg-getvalue result 0 0)))))
@end lisp

Use @code{pg-finish} to close an open connection.  Although this is not
strictly necessary (Guile-PG arranges for unreferenced connection
objects to be properly closed when they are garbage collected), failure
to do so before the process exits normally results in a (server side)
logfile entry ``unexpected EOF on client connection''.

@tsin i pg-finish

PostgreSQL 7.4 and later support the concept of @dfn{protocol version}.
@xref{Miscellaneous}, for another way to find installation metainfo.

@tsin i pg-protocol-version

Notices are messages sent from the back- to the front-end, sometimes prefixed
with the word @code{NOTICE}, and always followed by a trailing newline.  By
default, they are sent to the current output port.

@tsin i pg-set-notice-out!
@tsin i pg-reset
@tsin i pg-server-version
@tsin i pg-get-db
@tsin i pg-get-user
@tsin i pg-get-pass
@tsin i pg-get-host
@tsin i pg-get-port
@tsin i pg-get-tty
@tsin i pg-get-options
@tsin i pg-backend-pid
@tsin i pg-transaction-status
@tsin i pg-parameter-status

@section Asynchronous Notifications

The PostgreSQL back-end supports @dfn{asynchronous notifications}
with the commands @code{LISTEN} and @code{NOTIFY}.  You can use
@code{pg-notifies} to query the pending notifications queue
(@pxref{Asynchronous Retrieval}).

@tsin i pg-notifies

@section Character Encoding

The client's character encoding, represented by a string such as
"UNICODE", can be queried and set.

@tsin i pg-client-encoding
@tsin i pg-set-client-encoding!

@section Non-Blocking Mode

@tsin i pg-set-nonblocking!
@tsin i pg-is-nonblocking?

@c ---------------------------------------------------------------------------
@node    Retrieving Data
@chapter Procedures for Retrieving Data

To get an answer you have to ask a question, i.e., send either a command or a
query to the connection using either @code{pg-exec} or some combination of the
lower-level non-blocking operations that comprise @code{pg-exec}.

@menu
* Parameters::                  Strings containing typed placeholders.
* Synchronous Retrieval::       Using @code{pg-exec}.
* Asynchronous Retrieval::      Using pieces of @code{pg-exec}.
* Processing Results::          What to do with data and/or errors.
@end menu

@c ---------------------------------------------------------------------------
@node    Parameters
@section Parameters

The sections following this one revolve around describing the essential
method of communicating with the PostgreSQL server, namely, by sending
it a properly-constructed string representing a command or statement.
However, @dots{}

@quotation
The string is a stark data structure and everywhere
it is passed there is much duplication of process.
It is a perfect vehicle for hiding information.
@flushright
--- Alan Perlis
@end flushright
@end quotation

To reduce this inefficiency for heavily-repeated statements that may
differ only slightly from one instance to the next, PostgreSQL 7.4
introduced libpq variants that make use of @dfn{parameterized strings},
which are normal strings with embedded placeholders (such as @code{$1},
@code{$2}, and so on) that can be sent to the server accompanied by
@dfn{typed parameters}.  These operate similarly to the @code{PREPARE}
and @code{EXECUTE} SQL statements.

@xref{Synchronous Retrieval}.  @xref{Asynchronous Retrieval}.

Even if a statement is not heavily-repeated (thus offering little
performance improvement potential), using these variants can be
advantageous anyway since they remove the need for tricky and
error-prone sql-quoting.

Guile-PG wraps these variants differently from the way it does the other
libpq functions, departing from close congruence to the C-language
argument list in favor of a simplified, ``more Schemey'', interface.
The Scheme procedures take, in addition to the connection object and the
command or statement (parameterized string), a vector of parameters,
conventionally named @var{parms}.

@heading Restrictions
@erindex bad parameter-vector element
Guile-PG support for parameters is in its infancy.  All elements of
@var{parms} @strong{must} be strings otherwise a ``bad parameter-vector
element'' error is signalled.  Relatedly, the @dfn{binary parameters}
are not supported; only @dfn{text parameters} (strings) are supported
for now.  Basically, Guile-PG support is a step up from not having
parameters at all, but not (yet) fully generalized.

Here is an example of how to work within these restrictions:

@lisp
(define C (pg-connectdb ...))

(define (sel s . args)
  (apply format #f (string-append "SELECT " s ";")
         args))

(define (straightforward-square n)
  (pg-exec C (sel "~A * ~A" n n)))

(define (parameterized-square n)
  (pg-exec-params C (sel "$1::integer * $1::integer")
                  (vector (number->string n)
                          (number->string n))))

(define (single result)
  (pg-getvalue result 0 0))

(equal? (single (straightforward-square 42))
        (single (parameterized-square 42)))
@result{} #t
@end lisp

@noindent
In the future, it should be possible to specify @code{integer} in
@var{parms} instead of in the parameterized string.

@c ---------------------------------------------------------------------------
@node    Synchronous Retrieval
@section Synchronous Retrieval

This section describes the procedures @code{pg-exec}, @code{pg-exec-params}
and @code{pg-exec-prepared}.  @xref{Parameters}, for background info on the
latter two.

@tsin i pg-exec
@tsin i pg-exec-params
@tsin i pg-exec-prepared

@heading Example
This example defines a procedure @code{pg-exec/no-false} which wraps
@code{pg-exec} so that a @code{misc-error} is thrown instead of returning
false.  There are numerous other examples of @code{pg-exec} calls throughout
this chapter.

@lisp
(define (pg-exec/no-false conn sql)
  (or (pg-exec conn sql)
      (error (pg-error-message conn))))
@end lisp

@heading Notes
The entire result set is returned at once from a call to to @code{pg-exec}.
If a @code{SELECT} results in a very large number of tuples then this can be
a problem because it requires a large amount of memory.  In these cases it is
better to @code{DECLARE} a cursor over the @code{SELECT} and retrieve small
numbers of rows at a time using @code{FETCH}.  These commands can only be
issued between @code{BEGIN TRANSACTION/END TRANSACTION} pairs.  See the
PostgreSQL @code{declare(l)} and @code{fetch(l)} man pages for more details.

@c ---------------------------------------------------------------------------
@node    Asynchronous Retrieval
@section Asynchronous Retrieval

Sometimes you don't want to wait idly for @code{pg-exec} to complete --- for
example, the query is complicated and/or the results are large --- instead
preferring to do some other computation in the meantime.  In these cases, you
can interact with the database @dfn{asynchronously}, that is, you register a
query at one time, and check for its completion at a later time.  In between,
you can collect partial results and notifications, or decide to cancel the
query altogether.

@xref{Parameters}, for background info on @code{pg-send-query-params} and
@code{pg-send-query-prepared}.

@tsin i pg-send-query
@tsin i pg-send-query-params
@tsin i pg-send-query-prepared
@tsin i pg-get-result
@tsin i pg-consume-input
@tsin i pg-is-busy?
@tsin i pg-request-cancel
@tsin i pg-flush

@c ---------------------------------------------------------------------------
@node    Processing Results
@section Processing Results

The @dfn{result} of a command or query placed by @code{pg-exec} satisfies
predicate @code{pg-result?}.  It may encapsulate an error, row data, or other
status.  @xref{Retrieving Data}.

Guile-PG displays result objects in the following format:

@example
#<PG-RESULT:STATUS:NTUPLES:NFIELDS>
@end example

@noindent
@var{status} is the same as would be returned by
@code{pg-result-status} except without the @code{PGRES_} (it is
redundant); @var{ntuples} and @var{nfields} are integers,
the same as would be returned by @code{pg-ntuples} and @code{pg-nfields},
respectively.  Everything else appears literally as shown here.

@tsin i pg-result?
@tsin i pg-result-error-field
@tsin i pg-result-error-message
@tsin i pg-error-message
@tsin i pg-result-status

@heading Result Status Values
@table @code

@item PGRES_TUPLES_OK
The statement returned zero or more tuples.  The number of fields and tuples
returned can be determined from calls to @code{pg-nfields} and
@code{pg-ntuples} respectively.  The value of a given attribute (field)
of a given tuple can be determined by calling @code{pg-getvalue}.

@item PGRES_COMMAND_OK
The statement was a command (@code{INSERT}, @code{UPDATE}, @code{DELETE}
@code{CREATE TABLE}, @code{DROP TABLE} etc.),
which was executed without error.  The number of tuples affected by the
command can be determined by a call to @code{pg-cmdtuples}.

@item PGRES_EMPTY_QUERY
It is not known under which circumstances this result-status is returned.

@item PGRES_COPY_OUT
@itemx PGRES_COPY_IN
The statement was a @code{COPY <table> TO STDOUT}
or @code{COPY <table> FROM STDIN} (respectively).
@xref{Writing/Reading Data}.

@item PGRES_BAD_RESPONSE
This occurs when the @code{libpq} interface receives an unexpected response
from the back-end.  It indicates a problem with PostgreSQL.

@item PGRES_NONFATAL_ERROR
It is not known under which circumstances this result-status is returned.

@item PGRES_FATAL_ERROR
The command was not executable for some reason.  This is the returned status
when a syntax error is detected in the command, for example.

@end table

@heading Example
This contrived example defines a procedure to insert a record into a given
table, returning the number of tuples inserted (always one) or @code{#f} if an
error occurred.

@lisp
(define (insert-one-record conn table record)
  (let ((result (pg-exec conn
                         (format #f "INSERT INTO ~A VALUES ~A"
                                 table record))))
    (and result
         (eq? 'PGRES_COMMAND_OK (pg-result-status result))
         (string->number (pg-cmdtuples result)))))
@end lisp

@noindent
The procedure could be called as follows

@lisp
(insert-one-record conn "people" "('Warbucks', 'Oliver')")
@end lisp

@tsin i pg-binary-tuples?

@erindex Invalid field number
The procedures @code{pg-fmod}, @code{pg-ftype}, @code{pg-fname},
@code{pg-ftable}, @code{pg-ftablecol}, @code{pg-fformat}, @code{pg-ftype}
and @code{pg-fsize} can all throw an @dfn{Argument out of range} error
if the specified field does not exist in the result.

@tsin i pg-fmod
@tsin i pg-ntuples
@tsin i pg-nfields
@tsin i pg-cmdtuples
@tsin i pg-oid-value
@tsin i pg-fname
@tsin i pg-fnumber
@tsin i pg-ftable
@tsin i pg-ftablecol
@tsin i pg-fformat
@tsin i pg-getvalue

This example defines a procedure @code{tuple->alist} which returns a given
tuple as an alist, keyed on the field name.  It's not an especially efficient
procedure because it constructs the list of field-names afresh each time it's
called.

@lisp
(define (field-names result)
  (map (lambda (field)
         (pg-fname result field))
       (iota (pg-nfields result))))

(define (get-values result tuple)
  (map (lambda (field)
         (pg-getvalue result tuple field))
       (iota (pg-nfields result))))

(define (tuple->alist result tuple)
  (map (lambda (n v) (cons (string->symbol n) v))
       (field-names result)
       (get-values result tuple)))
@end lisp

@noindent
Field values can be extracted from the tuple using @code{assq-ref}, e.g.:

@lisp
(assq-ref (tuple->alist result 0) 'firstname)
@end lisp

@noindent
Using this procedure we can define a version of @code{for-each} which
iterates through the tuples returned from a given @code{SELECT} query:

@lisp
(define (for-each-tuple proc result)
  (let ((end (pg-ntuples result)))
    (do ((tuple 0 (1+ tuple)))
        ((= tuple end))
      (proc (tuple->alist result tuple)))))
@end lisp

@noindent
This implementation of @code{for-each-tuple} inherits inefficiency from the
@code{tuple->alist} procedure.

@heading Notes
The @code{pg-getvalue} procedure throws
@code{out-of-range} errors if either the @code{tuple} or @code{field-number}
arguments are out of range.

@tsin i pg-getisnull
@tsin i pg-ftype

@heading Example
This defines a procedure @code{field-type-name} which returns the type
name of a given attribute in a string.

A more efficient implementation would be to define
a type of connection which, when opened, issued the query to retrieve the
@code{pg_type} system table once.  An alist for looking up type names could
then be associated with each connection for faster subsequent access.

@lisp
(define CONN (pg-connectdb ...))

(define (field-type-name result fnum)
  (let ((result (pg-exec
                 CONN
                 (format #f "SELECT typname FROM pg_type WHERE oid = ~A"
                         (pg-ftype result fnum)))))
    (or (and result
             (eq? 'PGRES_TUPLES_OK (pg-result-status result))
             (< 0 (pg-ntuples result))
             (pg-getvalue result 0 0))
        "")))
@end lisp

@tsin i pg-fsize
@tsin i pg-getlength

@c ---------------------------------------------------------------------------
@node    Writing/Reading Data
@chapter Procedures for Copying Data

As of PostgreSQL 7.4, you can send arbitrarily-sized chunks of data after
issuing the @code{COPY <table> FROM STDIN} command.  Also, both send and
receive (with the @code{COPY <table> TO STDOUT} command) paths can be
performed asynchronously.  See below for the older (obsolete) interface.

@tsin i pg-put-copy-data
@tsin i pg-put-copy-end
@tsin i pg-get-copy-data

@heading Obsolete functions for COPY

There are two procedures for reading a line of data associated with the
command @code{COPY <table> TO STDOUT}.  For both, when the @dfn{end-of-copy
marker} is recognized, that means the results from the @code{COPY} command
have all been read and @code{pg-endcopy} should be called to resynchronize the
connection before any further calls to @code{pg-exec} on this connection.

@tsin i pg-getline
@tsin i pg-getlineasync

@heading Example
This example defines two functionally identical procedures that can be used
to retrieve the results of a @code{COPY <table> TO STDOUT} command.  The
second procedure optionally displays a list of received chunk sizes, if
passed a third argument.

@lisp
(define (copy-to-port conn port)
  (let loop ((line (pg-getline conn)))
    (if (string=? line "\\.")
        (pg-endcopy conn)
        (begin (format port "~A\n" line)
               (loop (pg-getline conn))))))

(define (copy-to-port-async conn port . show-chunk-sizes?)
  (let ((buf (make-string 32)))
    (let loop ((count (pg-getlineasync conn buf))
               (chunks '()))
      (if (< count 0)
          (begin
            (or (null? show-chunk-sizes?)
                (format port "chunk sizes: ~S\n" chunks))
            (pg-endcopy conn))
          (begin
            (display (substring buf 0 count) port)
            (loop (pg-getlineasync conn buf #t)
                  (cons count chunks)))))))
@end lisp

@heading Notes
It is an error to call @code{pg-getline} on a connection without first
executing a @code{COPY <table> TO STDOUT} command on that connection.
It is also an error to call @code{pg-getline} after a terminating line has
been received, without an intervening @code{COPY} command being issued on
that connection.

@tsin i pg-putline

@heading Example
This example defines a procedure @code{copy-from-port} which can be used
to supply data to a @code{COPY <table> FROM STDIN} command.

@lisp
(use-modules (ice-9 rdelim))

(define (copy-from-port conn port)
  (let loop ((line (read-line port)))
    (cond ((eof-object? line)
           (pg-putline conn "\\.\n")
           (pg-endcopy conn))
          (else
           (pg-putline conn line)
           (pg-putline conn "\n")
           (if (string=? line "\\.")
               (pg-endcopy conn)
               (loop (read-line port)))))))
@end lisp

@tsin i pg-endcopy

Although not readily apparent, another form of data copying is @dfn{formatted
output}, which is supported by Guile-PG via the @code{pg-print} procedure and
the accompanying @code{pg-make-print-options}.  Together these loosely mimic
the @code{PQprint} functionality provided by libpq.

@tsin i pg-make-print-options

@erindex due to @code{tmpfile(3)} failure
@tsin i pg-print

@c ---------------------------------------------------------------------------
@node    Large Objects
@chapter Procedures for Managing Large Objects

@heading Note
All of the operations on large objects must be carried out inside a
@code{BEGIN TRANSACTION/END TRANSACTION} pair.  Failure to do this
will result in a loss of synchronization between the back-end and the
@code{libpq} library, resulting in an unusable connection to the
database, and possible corruption of data.

@erindex lob flush
@erindex Error seeking on lo port
@erindex Error reading from lo port
@erindex fport_write
To keep things running smoothly, certain read and write operations flush their
internal buffers every once in a while.  If there are problems, they throw a
@dfn{lob flush} error.  In the case where an error occurs during the process
(Guile) wind-down, the error message is displayed to stderr instead.  There
are also @dfn{Error seeking on lo port}, @dfn{Error reading from lo port}
and @dfn{fport_write}; these are normal (scheme world) errors.

@erindex Invalid mode specification
@erindex memory error
Additionally, both @code{pg-lo-creat} and @code{pg-lo-open} can throw
@dfn{Invalid mode specification} and @dfn{memory} errors.

Guile-PG displays large-object port objects in the following format:

@example
#<PG-LO-PORT:MODE: ALOD:OID:CONN>
@end example

@noindent
@var{mode} is one of @code{closed}, @code{input-output}, @code{input},
@code{output} or @code{bogus}; @var{alod} is a large-object descriptor (small
integer similar to a file descriptor); @var{oid} is the OID (integer); and
@var{conn} is the printed representation of the connection (@pxref{Database
Connections}).  Everything else appears literally as shown here (including the
space in front of @var{alod}, unfortunately).  This format will likely change
by the time Guile-PG 1.0 is released.

@tsin i pg-lo-creat
@tsin i pg-lo-open
@tsin i pg-lo-unlink
@tsin i pg-lo-get-oid
@tsin i pg-lo-tell
@tsin i pg-lo-seek

@heading Note
It is possible to seek beyond the end of file opened only for reading, in
which case subsequent reads of the port will return an EOF object.

@tsin i pg-lo-read
@tsin i pg-lo-import
@tsin i pg-lo-export

@c ---------------------------------------------------------------------------
@node    Miscellaneous
@chapter Miscellaneous Procedures

This chapter describes procedures whose name begins with "pg-" that do not
necessarily belong in the other chapters.

@tsin i pg-guile-pg-loaded

@erindex Invalid verbosity
@tsin i pg-set-error-verbosity

@erindex due to @code{dup(3)} failure
@erindex due to @code{fopen(3)} failure
@tsin i pg-trace

@erindex due to @code{fclose(3)} failure
@tsin i pg-untrace

@heading Example
This example defines a pair of procedures @code{trace-on} and
@code{trace-off} which implement a higher-level trace procedure which
opens the required file and starts/stops the trace.

@lisp
(define trace-port (make-object-property))

(define (trace-on conn filename)
  (let ((port (open-output-file filename)))
    (set! (trace-port conn) port)
    (pg-trace conn port)))

(define (trace-off conn)
  (and=> (trace-port conn)
         (lambda (port)
           (close-port port)
           (set! (trace-port conn) #f)
           (pg-untrace conn))))
@end lisp

The next three procedures are for @dfn{escape processing}, changing one
single-quote char into two single-quote chars, and so forth.  The first two
are for data to be sent to the server, the third for data received from the
server.  If there are problems (when they return @code{#f}), you can use
@code{pg-error-message} to find out what happened.

@tsin i pg-escape-string-conn
@tsin i pg-escape-bytea-conn
@tsin i pg-unescape-bytea

For example:

@lisp
(pg-escape-string-conn CONN "abc'def")
@result{} "abc''def"

(pg-escape-bytea-conn
 CONN (string #\342 #\251 #\302 #\375))
@result{} "\\\\342\\\\251\\\\302\\\\375"
@end lisp

Lastly, the miscellaneous miscellaneous procedures!

@tsin i pg-mblen

@c ---------------------------------------------------------------------------
@node    Not Included
@chapter Not Included

This chapter lists @code{libpq} interface elements that are @strong{not}
provided by module @code{(database postgres)} and explains why they are
omitted.

@deffn {C Macro} PQsetdb
PostgreSQL documentation says:
@quotation
It is provided for backward compatibility with very old programs.
@end quotation

Since no one has asked for it in Guile-PG, we
assume no such programs exist.
@end deffn

@deffn {C Function} PQconnectStart
@deffnx {C Function} PQconnectPoll
@deffnx {C Function} PQresetStart
@deffnx {C Function} PQresetPoll
Laziness, pure and simple.
@end deffn

@deffn {C Function} PQstatus
More laziness.  Since we have @code{pg-reset}, we have the proper mechanism
for dealing with @code{PQstatus} values other than @code{CONNECTION_OK}.
@end deffn

@deffn {C Function} PQsocket
Unlikely to be useful.
@end deffn

@deffn {C Function} PQgetssl
We'll get to SSL support one of these days.
@end deffn

@deffn {C Function} PQresStatus
@deffnx {C Function} PQclear
@deffnx {C Function} PQmakeEmptyPGresult
@deffnx {C Function} PQcmdStatus
Unlikely to be useful.
@end deffn

@deffn {C Function} PQoidStatus
PostgreSQL documentation says:
@quotation
This function is deprecated in favor of PQoidValue.
It is not thread-safe.
@end quotation
@end deffn

@deffn {C Function} PQescapeString
@deffnx {C Function} PQescapeBytea
Deprecated in favor of @code{PQescapeStringConn}
and @code{PQescapeByteaConn}, respectively.
@end deffn

@deffn {C Function} PQfreemem
Internal.
@end deffn

@deffn {C Function} PQfn
PostgreSQL documentation says:
@quotation
Tip: This interface is somewhat obsolete, as one may achieve similar
performance and greater functionality by setting up a prepared statement
to define the function call.  Then, executing the statement with binary
transmission of parameters and results substitutes for a fast-path
function call.
@end quotation
@end deffn

@deffn {C Function} PQputnbytes
This is in the section ``Obsolete Functions for COPY''.
@end deffn

@deffn {C Function} PQsetNoticeReceiver
@deffnx {C Function} PQsetNoticeProcessor
We provide the schemefied interface @code{pg-set-notice-out!}.
@end deffn

@deffn {C Function} PQdisplayTuples
@deffnx {C Function} PQprintTuples
These ``really old printing routines'' are obsoleted by @code{pg-print}.
@end deffn

@deffn {C Function} PQenv2encoding
This function does @code{(getenv "PGCLIENTENCODING")} and returns the
numeric value of the result, which is not useful, since Guile-PG uses a
string to describe the client encoding (you can use the value from
@code{getenv} directly).  For example:

@example
(and=> (getenv "PGCLIENTENCODING")
       pg-set-client-encoding!)
@end example

@noindent
@xref{Database Connections}.
@end deffn

@c ---------------------------------------------------------------------------
@node    Query Construction
@chapter Query Construction

Constructing a typical SQL @code{SELECT} query (to be passed to @code{pg-exec})
can be tedious and error prone due to the many string-munging operations
involved.  Guile-PG provides some procedures to make things a little easier.

To get started, load the @code{postgres-qcons} module:

@lisp
(use-modules (database postgres-qcons))
@end lisp

@noindent
This provides procedures to render @dfn{prefix-style expressions} to SQL
syntax, essentially by constructing stylized trees (nested lists) and then
flattening them to a string on output.

@menu
* Prefix-Style Expressions: qcons intro.
* Special Operators: qcons special operators.
* Lookup Tables Extension: qcons extension.
* Quoting: qcons quoting.
* Tree Construction: qcons trees.
* Output: qcons output.
@end menu

@c ---------------------------------------------------------------------------
@node qcons intro
@section Prefix-Style Expressions

To be brutally honest, both SQL and Scheme revolve around structured
expressions (also known as @dfn{sexps}), so ascribing some elevated status to
the representation that ``supports sexps'' is really not saying much.  In the
Guile-PG maintainer's humble opinion, the advantage in expressiveness of Scheme
over SQL is not in the presence or lack of structure, but rather in the
regularity of the structure.

Scheme syntax is (as you probably already know) exceedingly easy to describe:
first there is the opening parenthesis, then the operator or function, then
the argument(s), and finally the matching closing parenthesis.  The
argument(s) can in turn be sub-expressions of their own.  This simplicity
stands in stark contrast to the myriad rules (and worse: exceptions to the
rules) that comprise the SQL language specification.

Thus, we call the mini-language described in this chapter @dfn{prefix-style
expressions} because it borrows from Scheme's regularity even though it is not
Scheme, per se.  This is the general form of a prefix-style expression:

@example
(operator [operand ...])
@end example

In words: An open parenthesis followed by a symbol @var{operator}
followed by zero or more @var{operand} arguments, each in turn a
prefix-style sub-expression, followed by the close parenthesis.
Components of these expressions may be symbols, keywords, numbers,
strings and matching parentheses.  Unlike Scheme, there is no quote,
quasiquote, unquote or unquote-splicing, although those facilities can
(and should) be used in a Scheme program to construct a prefix-style
expression.  Also unlike Scheme is the requirement that @var{operator}
be a symbol; it is not processed in the same way as each @var{operand}.

Usually, @var{operator} names an SQL function or operator.  For example,
the symbol @code{date_trunc} refers to the SQL function by the same name.
Guile-PG uses lookup tables to determine how to transform the prefix style
into either infix, postfix, functional or other layouts.

@node qcons special operators
@section Special Operators

Some operators are
handled specially:

@table @code
@item and
@itemx or
These infix operators are very common and are only mentioned because they do
not show up in the lookup tables.  (Do not be alarmed!)

@item (case PEXP (MAYBE1 VAL1) ... [(else DEFAULT-VAL)])
This maps to the SQL @code{CASE} statement:

@example
CASE exp
 WHEN maybe1 THEN val1 ...
 ELSE default
END
@end example

@noindent
where the changes from @code{PEXP}, @code{MAYBE1}, @code{VAL1} and
@code{DEFAULT-VAL} to @code{exp}, @code{maybe1}, @code{val1} and
@code{default}, respectively, involve recursive layout transforms.

@item (cond (MAYBE1 VAL1) ... [(else DEFAULT-VAL)])
This maps to the SQL @code{CASE} statement without the initial pexp:

@example
CASE
 WHEN maybe1 THEN val1 ...
 ELSE default
END
@end example

@noindent
where the changes from @code{MAYBE1}, @code{VAL1} and
@code{DEFAULT-VAL} to @code{maybe1}, @code{val1} and
@code{default}, respectively, involve recursive layout transforms.

@item (if PEXP YES-VAL NO-VAL)
This maps to the SQL @code{CASE} statement:

@example
CASE exp
 WHEN 't' THEN yes
 WHEN 'f' THEN no
END
@end example

@noindent
where the changes from @code{PEXP}, @code{YES-VAL} and
@code{NO-VAL} to @code{exp}, @code{yes} and
@code{no}, respectively, involve recursive layout transforms.
Note that @dfn{one-armed if} is not permitted.

@item (:: TYPE PEXP)
This maps to the SQL @code{CAST} statement:

@example
CAST exp AS type
@end example

@noindent
where the change from @code{PEXP} to @code{exp} involves a recursive layout
transform.  Note that the result is identical to using (SQL) suffix
@code{::TYPE}; the operator @code{::} was actually chosen with this
mnemonic in mind.

@item (in/set PEXP0 PEXP1...)
This maps to the SQL expression:

@example
exp0 IN ( exp1, ... )
@end example

@noindent
where the change from each @code{PEXP} to @code{exp} involves a recursive
layout transform.  Parentheses and comma are added automatically.
For @code{NOT IN}, use @code{(not (in/set ...))}.

The name @code{in/set} was chosen to emphasize that this particular usage
of the SQL keyword @code{IN} is to check for set membership.  (The
operator @code{in/sel} is reserved for future implementation of @code{IN}
as sub-select.)

@item (between PEXP PEXP-LO PEXP-HI)
This maps to the SQL expression:

@example
( exp BETWEEN exp-lo AND exp-hi )
@end example

@noindent
where the change from each @code{PEXP} to @code{exp} involves a recursive
layout transform.  Parentheses are added automatically.
For @code{NOT BETWEEN}, use @code{(not (between ...))}.

@item  (any--@var{op} PEXP ARRAY-PEXP)
@itemx (all--@var{op} PEXP ARRAY-PEXP)
These map to the respective SQL expressions:

@example
( exp @var{op} ANY array-exp )
( exp @var{op} ALL array-exp )
@end example

@noindent
where @var{op} is a valid comparison operator (e.g., @code{=}),
and the change from @code{PEXP} and @code{ARRAY-PEXP} to @code{exp} and
@code{array-exp}, respectively, involves a recursive layout transform.
Parentheses are added automatically.

The @code{--} syntax was chosen to avoid potential namespace conflicts;
according the PostgreSQL documentation (section 4.1.3, Operators):

@quotation
There are a few restrictions on operator names, however: @code{--} and
@code{/*} cannot appear anywhere in an operator name, since they will be
taken as the start of a comment.
@end quotation
@end table

A symbol appearing in the operands, or alone without parentheses (i.e., in a
non-operator position), it is taken to be a column name or reference.

Strings are always passed through @code{sql-quote} unless they have been
previously been passed through @code{sql-pre}.

Numbers are passed through w/o change.

The documentation for the procedures described in this chapter often uses
@dfn{pexp} to stand for prefix-style expression.  Some procedures take a pexp
(or list of them), while others take a more complex structure usually
involving some extra specification composed with a single pexp.

@c ---------------------------------------------------------------------------
@node qcons extension
@section Lookup Tables Extension

During tree construction, internal lookup tables control the rendering
transformations.  You can add to them using procedure @code{qcons-declare!}.

@tsin i qcons-declare!

The rest of this section presents various lists of built-in declarations.
Using @code{qcons-declare!} on a built-in symbol overwrites the associated
value (if any).  There is no @dfn{undeclare} support.

@include qcons-tables.texi

@c ---------------------------------------------------------------------------
@node qcons quoting
@section Quoting

Ideally, the tree construction procedures in the following section would
be powerful enough to do the right thing given a well-formed prefix-style
expression.  However, sometimes reality intrudes and you need to craft SQL
directly.  In these cases, it still may be a good idea to use the tree
construction procedures for most of the work and tweak only the small parts that
need it.  This selective use of varying expression construction approaches is
known prosaically as @dfn{quoting}.

@tsin i sql-pre
@tsin i sql-pre?
@tsin i sql-unpre
@tsin i sql-quote
@tsin i idquote

@section Standard Conforming Strings

Starting with PostgreSQL 8.x, there is a configuration file and runtime
parameter @code{standard_conforming_strings} that controls how strictly the
server parses SQL string syntax.  When its value is @code{on}, strings that
include the @samp{\} (backslash) character must be prefixed with @samp{E}.
Even when it is off, the server may emit a warning, anyway.  To avoid such
unpleasantness, Guile-PG provides @code{sql-quote-auto-E?}.

@findex sql-quote-auto-E?
@tsin i sql-quote-auto-E?

@noindent
The typical way to use this is to set the fluid soon after you make the
connection and forget about it:

@example
(and (pg-parameter-status CONN 'standard_conforming_strings)
     ;; Don't bother checking the parameter value;
     ;; enable functionality unconditionally.
     (fluid-set! sql-quote-auto-E? #t))
@end example

@noindent
This can get hairy if you maintain more than one connection at a time to
servers with mixed support for @code{standard_conforming_strings}, however
(i.e., pre-8.x and 8.x together).  In that case, it is better to use
@code{with-fluids} to enable the functionality completely dynamically.

@c ---------------------------------------------------------------------------
@node qcons trees
@section Tree Construction

This section describes the tree construction procedures, most of which are
still (at this time, 2005-02-24) considered @strong{experimental}.  You should
take this as an invitation to @strong{experiment} and share your observations w/
the Guile-PG maintainer so that we can refine them nicely for the 1.0 release.

@tsin i make-comma-separated-tree
@tsin i make-WHERE-tree
@tsin i make-GROUP-BY-tree
@tsin i make-HAVING-tree
@tsin i make-ORDER-BY-tree
@tsin i make-SELECT/COLS-tree
@tsin i make-FROM-tree
@tsin i make-SELECT/FROM/COLS-tree
@tsin i parse+make-SELECT/tail-tree
@tsin i parse+make-SELECT-tree

@c ---------------------------------------------------------------------------
@node qcons output
@section Output

To get SQL once the tree is constructed, you have to flatten it.

@tsin i sql<-trees
@tsin i sql-command<-trees

@c ---------------------------------------------------------------------------
@node    Displaying Results
@chapter Displaying Results

If procedure @code{pg-print} does not do what you want (@pxref{Writing/Reading
Data}), you can try a slightly more customizable method for displaying
results.

To get started, load the @code{postgres-resdisp} module:

@lisp
(use-modules (database postgres-resdisp))
@end lisp

@tsin i display-result

@c ---------------------------------------------------------------------------
@node    Types Conversion
@chapter Types Conversion

Normally, the result of a @code{pg-exec} query is an object from which Scheme
strings can be extracted to represent the datum from a particular tuple/field
coordinate, using @code{pg-getvalue} (@pxref{Retrieving Data}).  If this
string is sufficient for your needs, you can skip this chapter, which
describes how to use the PostgreSQL-to-Scheme (and back) type conversion
support installed with Guile-PG, including how to register new converters.

To get started, load the @code{postgres-types} module:

@lisp
(use-modules (database postgres-types))
@end lisp

@noindent
But before we get to conversions, recall that the @code{pg-ftype} example
(@pxref{Processing Results})
defines a procedure that returns the name of a PostgreSQL type by doing a
query on the @code{pg_type} (internal) table.  Here is a more efficient
implementation:

@lisp
(define CONN (pg-connectdb ...))

(define (pg-ftype-name result fnum)
  (assq-ref (oid-type-name-cache CONN)
            (pg-ftype result fnum)))
@end lisp

@noindent
It uses a bonus procedure in this module:

@tsin i oid-type-name-cache

@menu
* Consulting Existing Type Converters::
* Selected Notes About Some Types::
* Defining New Type Converters::
@end menu

@node    Consulting Existing Type Converters
@section Consulting Existing Type Converters

To see what type converters are already defined, use the @code{dbcoltypes}
procedure.  To get a @dfn{type-converter object} that encapsulates
the @dfn{stringifier}, the @dfn{objectifier} and the @dfn{default}, use
the procedure
@code{dbcoltype-lookup}.  The components of the returned object can be read
using the @code{dbcoltype:FOO} procedures.

@tsin i dbcoltypes
@tsin i dbcoltype-lookup
@tsin i dbcoltype:stringifier
@tsin i dbcoltype:objectifier
@tsin i dbcoltype:default

Here is a simple example that uses @code{dbcoltype-lookup} and
@code{dbcoltype:objectifier} to convert a @code{text[][]} value
into a nested list:

@lisp
(let ((raw (pg-getvalue result 0 0))
      (conv (dbcoltype:objectifier (dbcoltype-lookup 'text[][]))))
  (format #t "~A\n~A\n" raw (conv raw)))

@print{} @{@{a,b@},@{c,d@}@}
@print{} (("a" "b") ("c" "d"))
@end lisp

@noindent
Note that even though the type is an "array", as implied by the square
brackets, the result is a list.  This is mostly due to a limitation in
PostgreSQL: dimensionality is not stored for array types, so the conversion
cannot be done in a random-access manner.  Perhaps this will change in the
future.

@node    Selected Notes About Some Types
@section Selected Notes About Some Types

For the most part, the built-in converters map Scheme types to PostgreSQL
types almost transparently (@pxref{Consulting Existing Type Converters}).
This section lists the PostgreSQL types not (yet) covered, describes the major
weakness in the mapping approach, and then finally touches upon some of the
rough edges to be found in selected cases.  We hope to resolve these issues
(and thus be able to revise this section significantly) before Guile-PG 1.0 is
released.

Converters for the following PostgreSQL 7.4.17 types are not provided.
(Dot-separated numbers indicate a section in the PostgreSQL User's Guide
describing the type.)

@table @code

@item double precision
Numeric Types (8.1).  Guile-PG provides @code{double} instead of
@code{double precision}.

@item money
Monetary Type (8.2).  Since PostgreSQL itself deprecates this type,
it is unlikely Guile-PG will support it ever.

@item character varying (n)
@itemx char (n)
Character Types (8.3).  Guile-PG provides @code{varchar} instead of
@code{character varying}, and @var{character} instead of @var{char}.

@item timestamp [ (p) ] with time zone
@itemx interval [ (p) ]
@itemx date
@itemx time [ (p) ] with time zone
@itemx time [ (p) ] without time zone
Date/Time Types (8.5).

@item point
@itemx line
@itemx lseg
@itemx box
@itemx path
@itemx polygon
@itemx circle
Geometric Types (8.7).

@item bit (n)
@itemx bit varying (n)
Bit String Types (8.9).

@item regproc
@itemx regprocedure
@itemx regoper
@itemx regoperator
@itemx regclass
@itemx regtype
Object Identifier Types (8.11).

@item record
@itemx any
@itemx anyarray
@itemx void
@itemx trigger
@itemx language_handler
@itemx cstring
@itemx internal
@itemx opaque
Pseudo-Types (8.12).

@end table

The large table above hints at the major weakness in Guile-PG's type mapping
approach: the names of type converters and the names of the PostgreSQL types
are not decoupled at all.  This has several negative consequences:

@enumerate

@item Non-alphanumeric characters in the PostgreSQL type name are not handled
gracefully.  For example, @code{double precision} has a space; Guile-PG can
provide @code{double}, but now there is ambiguity upon reflection, and
the single-table abstraction @code{#:create} method fails.

@item When there is no native Guile type that maps cleanly, Guile-PG must
choose an object representation, which may not be ideal for the client.
For example, Guile-PG defines an @code{inet} object to be a two-element
vector; perhaps client code uses a cons or simply one number, since all its
@code{inet} objects are host addresses (constant netmask).  Sure, it is no big
deal to box/unbox, but that's an extra level of conversion that the whole
system was trying to avoid in the first place.

@item User-defined types can clobber internals.
(Actually, this may not be a problem in practice.)

@item Parameterized types cannot be specified.

@item Non-array derived types cannot express their lineage.
For example, Guile-PG provides @code{inet-host}, but the
single-table abstraction @code{#:create} method fails because
it has no way of finding out that this type is based on @code{inet}.

@item [probably other things i can't recall at the moment... --ttn]

@end enumerate

The rest of this section is a table delving into some of the more quirky type
converters provided, including those that do not have a PostgreSQL type.
Entries marked @code{NOCREATE} indicate that the converter is for a synthetic
type and that it cannot be used in the single-table abstraction to create a
table, either because there is no underlying PostgreSQL type, or because
information about such an underlying type is not (presently) available.
Entries marked @code{INTERNAL} are ``not intended for use by the general
user'', according to the PostgreSQL User's Guide.  Entries marked
@code{EXPERIMENTAL} should probably be avoided unless you are interested in
debugging Guile-PG itself.

@table @code

@item double
NOCREATE.  This can be used to access data of PostgreSQL type
@code{double precision}.

@item char
@itemx name
NOCREATE, INTERNAL.  PostgreSQL actually provides a @code{"char"} type (name
includes the double quotes) that this type (name does not include the double
quotes) mimics.

@item timestamp
This can be used to access data of PostgreSQL type @code{timestamp (0) without
time zone}.

@item inet
@itemx cidr
Guile has no native type that aggregates the address and the netmask, so
Guile-PG defines the Scheme @code{inet} or @code{cidr} object to be a
vector of two elements @code{#(@var{address} @var{maskcount})} where
@var{address} is a positive integer zero through @code{#xffffffff} (32
bits) and @var{maskcount} is the number of bits in the netmask.  If
@var{maskcount} has value 32, that indicates that @var{address} is a
host address (not a network).

@item inet-host
NOCREATE.  The @code{inet-host} converter can be used to access data of
PostgreSQL type @code{inet} or @code{cidr} when all the data values have a
netmask value of 32.  The Scheme @code{inet-host} object is a positive integer
zero through @code{#xffffffff} (32 bits).

@item aclitem
EXPERIMENTAL.  Presently used by module @code{(database postgres-meta)}
in a pass-through (semantically opaque) manner.  (This is another way
of saying we don't know what the hell this is good for, but there it is,
anyway. ;-)

@end table

@node    Defining New Type Converters
@section Defining New Type Converters

To define a new non-array type means associating with the type name a
procedure for converting from a PostgreSQL string representation to a Scheme
object (the @dfn{objectifier}), a procedure to do the conversion in the
opposite direction (the @dfn{stringifier}), and a default string to use if
none is specified (for example, during an @code{INSERT} operation).  For this,
use the @code{define-db-col-type} procedure.

@tsin i define-db-col-type

To express conversion of arrays (no matter the dimensionality) of non-array
types, use the @code{define-db-col-type-array-variant} procedure.

@tsin i define-db-col-type-array-variant

@c ---------------------------------------------------------------------------
@node    Column Definitions
@chapter Column Definitions

A column definition, or @dfn{def} for short, associates a column name, its
type and any additional options.  It has the form:

@lisp
(NAME TYPE [OPTIONS...])
@end lisp

@noindent
@var{name} and @var{type} are symbols specifying the name and type of the
column, respectively (@pxref{Types Conversion}).  @var{options} are strings
passed directly to PostgreSQL as part of a @code{CREATE TABLE} command.  For
example, the status output of the rsync(1) program can be specified by the
form:

@lisp
(define rsync-defs
        '((time            timestamp)
          (error_condition text)
          (files           text[])
          (wrote           int4)          ; bytes
          (read            text[][])
          (rate            float4)
          (total           int4)          ; bytes
          (speedup         float4)
          (etc             int4[])))
@end lisp

@noindent
Likewise, here is an example that might be useful in keeping a table of
expenses (although probably using @code{float4} is not a good idea for
monetary values):

@lisp
(define expense-ledger-defs
        '((i       serial)
          (date    timestamp)
          (amount  float4)
          (details text[])))
@end lisp

@noindent
Note that there are no options in these examples.  The components of a def can
be extracted with procedures in the @code{postgres-col-defs} module, which can
be loaded like so:

@lisp
(use-modules ((database postgres-col-defs)
              #:renamer (symbol-prefix-proc 'def:)))
@end lisp

@noindent
In this example, we use the @code{#:renamer} clause to systematically prefix
"def:" to the names that the client module would see (resulting in
@code{def:column-name} and so on).

@tsin i column-name
@tsin i type-name
@tsin i type-options
@tsin i validate-def

There are two more convenience procedures, the first one useful in
transforming the results of a query into Scheme objects (@pxref{Result
Transforms}):

@tsin i objectifiers
@tsin i stringifiers

@c ---------------------------------------------------------------------------
@node    Result Transforms
@chapter Result Transforms

To support handling of query results in the @dfn{Scheme domain}, Guile-PG
provides various procedures to walk the result object, to extract Scheme
objects from the result object, and to collect these in idiomatic data
structures (such as the association list).

To get started, load the @code{postgres-resx} module:

@lisp
(use-modules (database postgres-resx))
@end lisp

@noindent
The most basic procedure is @code{for-each-tuple}, useful for quick searches
on the unconverted result strings.

@tsin i for-each-tuple

The rest of the procedures in this chapter combine conversion of the raw
result strings to Scheme objects, with different collection methods.
@xref{Types Conversion}.  (For access to the unconverted result strings, use
the procedure @code{identity} as the @dfn{objectifier}, which in effect does
no conversion at all.)

The degenerate collection method is no collection at all!  (A common idiom is
to @code{SELECT EXPR;} to get a result consisting of one row and one column.)

@tsin i object<-result

For other collection methods, we include examples to clarify.
The examples are based upon a result object that can briefly described as:

@itemize
@item two tuples each with two fields
@item field names: "date" and "note"
@item first tuple's date: "2003-01-14 00:00:00-08"
@c                         1042531200
@item first tuple's note: "now", "the present"
@item second tuple's date: "2003-01-13 00:00:00-08"
@c                          1042444800
@item second tuple's note: "yesterday", "the past"
@end itemize

The defs (@pxref{Column Definitions}) for the examples are:

@lisp
(define defs '((date timestamp) (note text[])))
@end lisp

@noindent
Actually the @code{note} field in its raw form involves curly braces and extra
quoting, but we omit that to reduce clutter.

The @code{result-field->object-list} procedure is useful for single-column
queries.

@tsin i result-field->object-list

@heading Example
@lisp
(define (1-col result fn type)
  (let ((objectifier (dbcoltype:objectifier (dbcoltype-lookup type))))
    (result-field->object-list result fn objectifier)))

(1-col result 0 'timestamp)
@result{} (1042531200 1042444800)

(1-col result 1 'text[])
@result{} (("now" "the present") ("yesterday" "the past"))
@end lisp

@noindent
The @code{result->object-FOO} procedures
have the same signature but return the data in different ways.

@tsin i result->object-alist
@tsin i result->object-alists
@tsin i result->object-rows

@heading Example
@lisp
(use-modules ((database postgres-col-defs) #:select (objectifiers)))

(define odefs (objectifiers defs))

(result->object-alist result odefs)
@result{}
((date 1042531200 1042444800)
 (note ("now" "the present") ("yesterday" "the past")))

(result->object-alists result odefs)
@result{}
(((date . 1042531200) (note "now" "the present"))
 ((date . 1042444800) (note "yesterday" "the past")))
@end lisp

@c ---------------------------------------------------------------------------
@node    Single-Table Abstraction
@chapter Single-Table Abstraction

Sometimes it is convenient to focus on a single table, adding rows to it or
drawing queries from it exclusively of any other tables in the database.
Likewise with a view, except that only queries are possible.  This chapter
describes Guile-PG facilities for this kind of use.

To get started, load the @code{postgres-table} module:

@lisp
(use-modules (database postgres-table))
@end lisp

@noindent
Basically, the @code{pgtable-manager} procedure encapsulates specification,
query and mutation (including create/delete) of a PostgreSQL table; and the
@code{pgtable-worker} procedure encapsulates @code{pgtable-manager}.

@tsin i pgtable-manager
@tsin i compile-outspec
@tsin i pgtable-worker

The other procedures are useful for succinctly codifying queries, and
translating the result en mass to Scheme objects.  [NOTE: These will
definitely migrate to other modules at some point before 1.0 release.]

@tsin i sql-pre

The rest of this chapter is an extended example showing some of the uses of
@code{pgtable-manager}.

@lisp
(define m (pgtable-manager "ttn" "guile_pg_demo"
                           '((i          serial)
                             (date       timestamp)
                             (amount     float4)
                             (catcode    text)
                             (details    text[]))))

((m #:create))
@result{} #<PG-RESULT:COMMAND_OK:0:0>

(define add (m #:insert-col-values))
(define sel (m #:select))

(add '(date amount) (current-time) 1.98)
@result{} #<PG-RESULT:COMMAND_OK:0:0>

(add '(date amount) (current-time) 2.98)
@result{} #<PG-RESULT:COMMAND_OK:0:0>

(define (under n)
  (sel '((integer #f (count *)))  ;; outspec
       #:where `(< amount ,n)))   ;; prefix-style expression

(define result (under 2.00))

result
@result{} #<PG-RESULT:TUPLES_OK:1:1>

((m #:tuples-result->object-alist) result)
@result{} ((count 1))

((m #:drop))
@result{} (#<PG-RESULT:COMMAND_OK:0:0> #<PG-RESULT:COMMAND_OK:0:0>)
@end lisp

Two things to note in this example: (1) Both @code{#:create} and @code{#:drop}
invocations evaluate the operating thunk directly (double parentheses); and
(2) The drop returns a list of result values to accommodate the possibility
(shown here) of a @code{serial} column type, which requires an additional drop
of the associated PostgreSQL @dfn{sequence} used to implement the expected
serial behavior.  (As of PostgreSQL 7.x, the sequence name is constructed like
so: @code{TABLENAME_COLNAME_seq}.  For more info, see the PostgreSQL User Guide,
Chapter 3: Data Types.)

@c ---------------------------------------------------------------------------
@node    Introspection
@chapter Introspection

This chapter explains the introspection facilities, which admittedly are not
(yet) very well developed in Guile-PG.  [During the alpha releases, these will
surely change quite a bit; your feedback is welcome.]

To get started, load the @code{postgres-meta} module:

@lisp
(use-modules (database postgres-meta))
@end lisp

Guile-PG supports standard as well as funky introspection.

@menu
* Standard Introspection::      Playing with the @code{information schema}.
* Funky Introspection::         Implementation-specific peerings.
@end menu

@c ---------------------------------------------------------------------------
@node    Standard Introspection
@section Standard Introspection

The PostgreSQL documentation says:

@quotation
The @dfn{information schema} consists of a set of views that contain
information about the objects defined in the current database.  The
information schema is defined in the SQL standard and can therefore be
expected to be portable and remain stable---unlike the system catalogs,
which are specific to PostgreSQL and are modelled after implementation
concerns.  The information schema views do not, however, contain
information about PostgreSQL-specific features; to inquire about those
you need to query the system catalogs or other PostgreSQL-specific
views.
@end quotation

This section describes Guile-PG support for querying the information schema.
For PostgreSQL-specific features, @xref{Funky Introspection}.

@tsin i information-schema-names
@tsin i information-schema-coldefs

To see everything about everything, for example, you can try:

@example
(define (spew name)
  (pg-print (pg-exec CONN (simple-format
                           #f "SELECT * FROM ~A;"
                           name))))

(for-each spew (information-schema-names #t))
@end example

@c ---------------------------------------------------------------------------
@node    Funky Introspection
@section Funky Introspection

@noindent
The column definitions of an existing table can be discovered to some extent
by the @code{defs-from-psql}, @code{infer-defs} and @code{describe-table!}
procedures, the last one also displaying details on field/column innards.

@tsin i defs-from-psql
@tsin i infer-defs
@tsin i describe-table!

Once you have a set of defs, you can verify that their types are supported by
Guile-PG with the following procedures.

@tsin i check-type/elaborate
@tsin i strictly-check-types/elaborate!

@heading Example
@lisp
(define DEFS (defs-from-psql #t "glug" "updok"))

(car DEFS)
@result{} (time timestamp "without time zone not null")

(map type-name DEFS)
@result{} (timestamp integer integer real integer real)

(strictly-check-types/elaborate! "updok" (map type-name DEFS))
@print{}
ERROR: bad "updok" types: (real real)
ABORT: (misc-error)
@end lisp

In this example, we use the external program @file{psql} to find out the defs
for the table @code{updok} in database @code{glug}; use @code{type-name} to
get the types (@pxref{Column Definitions}); and finally check to see which
ones, if any, are unknown to Guile-PG.  The error output lists @code{real}
twice because two of the @code{DEFS} have that type.

@c ---------------------------------------------------------------------------
@node    Easy Interaction
@chapter Easy Interaction

Sometimes you just want to poke around manually, interacting with a database
connection by typing in exploratory commands, and the external command-line
program psql(1) does not provide enough insight or customizability (or perhaps
is not available).  This chapter presents an alternative method for running
such a @sc{repl} (read-eval-print loop).

To get started, load the @code{postgres-gxrepl} module:

@lisp
(use-modules (database postgres-gxrepl))
@end lisp

@noindent
This provides the procedure @code{gxrepl}.  The ``gx'' stands for ``guile
extensible'', which is not the case at the moment, but we have great and
humble plans for this module...

@tsin i gxrepl

Most comma commands are relatively self-explanatory, with guidance from
@code{,help}.  The rest of this chapter delves into some of the more
arcane commands.

Primarily, the @dfn{fixed-part select} is an exploratory type of interaction
where you can @dfn{fix} certain parts of a normal @code{select} query so that
you can concentrate on varying the rest.

For example:

@example
,fix #:from icbmcoords
Use the table icbmcoords (with columns one, two and importance).

,fsel one two #:where (< 9 importance)
Select some tuples.

,fix #:cols ("latitude" . one) ("longitude" . two)
More descriptive titles.

,fix #:where (< 9 importance) (> 3 importance)
We are scatterbrained, which helps ameliorate the evilness.

,fix #:where/combiner or
Uh oh, wits recovered, we once again are a menace.
@end example

@noindent
For comparison, here is the last example again, recast into SQL:

@example
SELECT one AS "latitude", two AS "longitude"
  FROM icbmcoords
 WHERE ((9 < importance) OR (3 > importance));
@end example

@c Local variables:
@c coding: utf-8
@c End:
@c ref.texh ends here
